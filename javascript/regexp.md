# 正则表达式

正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 `RegExp` 的 `exec` 和 `test` 方法，以及 String 的 `match`、`matchAll`、`replace`、`search` 和 `split` 方法。

## 创建正则表达式

使用正则表达式字面量
` var reg = /ab+c/ `
脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能。

或者调用RegExp对象的构造函数，如下所示：
` var re = new RegExp("ab+c") `
在脚本运行过程中，用构造函数创建的正则表达式会被编译。如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式。

## 特殊字符

### 断言（Assertions）

断言的组成之一是边界。对于文本、词或模式，边界可以用来表明它们的起始或终止部分（如先行断言，后行断言以及条件表达式）。

#### 边界类断言

字符 | 含义
---|---
^ | 匹配输入的开头。如果多行模式设为 true，^ 在换行符后也能立即匹配，比如 /^A/ 匹配不了 "an A" 里面的 "A"，但是可以匹配 "An A" 里面第一个 "A"。
$ | 匹配输入的结束。如果多行模式设为 true，$ 在换行符前也能立即匹配，比如 /t$/ 不能匹配 "eater" 中的 "t"，但是可以匹配 "eat" 中的 "t"。
\b | 匹配一个单词的边界，这是一个字的字符前后没有另一个字的字符位置，例如在字母和空格之间。需要注意的是匹配的单词边界不包括在匹配中。换句话说，匹配字边界的长度为零。<br>一些例子： <br>/\bm/ 在 "moon" 中匹配到 "m" <br>/oo\b/ 在 "moon" 中不会匹配到 "oo", 因为 "oo" 后面跟着 "n" 这个单词字符。 <br>/oon\b/ 在 "moon" 中匹配 "oon"，因为 "oon" 是这个字符串的结尾，因此后面没有单词字符 <br>/\w\b\w/ 将永远不会匹配任何东西，因为一个单词字符后面永远不会同时有一个非单词字符和一个单词字符。
\B | 匹配非单词边界。这是上一个字符和下一个字符属于同一类型的位置：要么两者都必须是单词，要么两者都必须是非单词，例如在两个字母之间或两个空格之间。字符串的开头和结尾被视为非单词。与匹配的词边界相同，匹配的非词边界也不包含在匹配中。例如，/\Bon/ 在“at noon”中匹配“on” ，/ye\B/ 在 "possibly yesterday"中匹配"ye" 。
#### 其他断言
字符 | 含义
---|---
x(?=y) | 先行断言： x 被 y 跟随时匹配 x。例如，对于/Jack(?=Sprat)/，“Jack”在跟有“Sprat”的情况下才会得到匹配．/Jack(?=Sprat\|Frost)/ “Jack”后跟有“Sprat”或“Frost”的情况下才会得到匹配。不过，匹配结果不包括“Sprat”或“Frost”。
x(?!y) | 先行否定断言： x 没有被 y 紧随时匹配 x。例如，对于/\d+(?!\.)/，数字后没有跟随小数点的情况下才会得到匹配。对于/\d+(?!\.)/.exec(3.141)，匹配‘141’而不是‘3’。
(?<=y)x | 后行断言： x 跟随 y 的情况下匹配 x。例如，对于/(?<=Jack)Sprat/，“Sprat”紧随“Jack”时才会得到匹配。对于/(?<=Jack|Tom)Sprat，“Sprat”在紧随“Jack”或“Tom”的情况下才会得到匹配。不过，匹配结果中不包括“Jack”或“Tom”。
(?<!y)x | 后行否定断言： x 不跟随 y 时匹配 x。例如，对于/(?<!-)\d+/，数字不紧随 - 符号的情况下才会得到匹配。对于/(?<!-)\d+/.exec(3) ，“3”得到匹配。 而/(?<!-)\d+/.exec(-3)的结果无匹配，这是由于数字之前有 - 符号。

### 字符类（Character Classes）

区分不同类型的字符，例如区分字母和数字

字符 | 含义
---|---
[xyz] [a-c]	|  一个字符类。匹配包含在方括号中的任何字符。你可以使用连字符指定字符范围，但如果连字符出现在方括号中的第一个或最后一个字符，则将其视为字面连字符，作为普通字符包含在字符类中。 <br> 例如，[abcd] 与 [a-d] 相同。它们匹配“brisket”中的“b”和“chop”中的“c”。 <br> 例如，[abcd-] 和 [-abcd] 匹配“brisket”中的“b”、“chop”中的“c”和“non-profit”中的“-”（连字符）。 <br> 例如，[\w-] 与 [A-Za-z0-9_-] 相同。它们都匹配“brisket”中的“b”、“chop”中的“c”和“non-profit”中的“n”。
[\^xyz] [\^a-c] |  一个否定或补充的字符类。也就是说，它匹配未包含在方括号中的任何字符。你可以使用连字符指定字符范围，但如果连字符出现在^后的第一个字符或方括号中的或最后一个字符，则将其视为字面连字符，作为普通字符包含在字符类中。例如，[\^abc] 与 [\^a-c] 相同。它们首先匹配“bacon”中的“o”和“chop”中的“h”。
\. | 有下列含义之一 ： <br>匹配除行终止符之外的任何单个字符：\n, \r, \u2028 or \u2029. 例如，/.y/ 在“yes make my day”中匹配“my”和“ay”，而不是“yes”。<br>在字符集内，点失去了它的特殊意义，并与文字点匹配。<br>需要注意的是，m multiline 标志不会改变点的行为。因此，要跨多行匹配一个模式，可以使用字符集[^]—它将匹配任何字符，包括新行。
\d |  匹配任何数字 (阿拉伯数字)。相当于 [0-9]。例如，/\d/ 或 /[0-9]/ 匹配“B2is the suite number”中的“2”。
\D | 匹配任何非数字 (阿拉伯数字) 的字符。相当于[^0-9]。例如，/\D/ 或者 /[^0-9]/ 匹配“B2 is the suite number”中的“B”。
\w | 匹配基本拉丁字母中的任何字母数字字符，包括下划线。相当于 [A-Za-z0-9_]。例如，/\w/ 匹配“apple”中的“a”，匹配“$5.28”中的“5”，匹配“3D”中的“3”，以及匹配“Émanuel”中的“m”。
\W | 匹配任何不是来自基本拉丁字母的单词字符。相当于 [^A-Za-z0-9_]。例如，/\W/ 或者 /[^A-Za-z0-9_]/ 匹配“50%”中的“%”，以及匹配“Émanuel”中的“É”。
\s | 匹配单个空白字符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。相当于 [\f\n\r\t\v\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，\s\w*/ 匹配“foo bar”中的“bar”。
\S | 匹配除空格以外的单个字符。相当于 [^\f\n\r\t\v\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\S\w*/ 匹配“foo bar”中的“foo”。
\t | 匹配水平制表符。
\r | 匹配回车符。
\n | 匹配换行符。
\v | 匹配垂直制表符。
\f | 匹配换页符。
[\b] | 匹配退格键。如果您正在寻找单词边界字符（\b），请参阅断言。
\0 | 匹配一个 NUL 字符。不要在此后面加上另一个数字。
\cX	| 使用插入符号匹配控制字符，其中“X”是 A–Z 中的一个字母（对应于代码点 U+0001–U+001F）。例如，/\cM\cJ/匹配“\r\n”。
\xhh | 匹配与代码 hh（两个十六进制数字）对应的字符。
\uhhhh | 匹配与值 hhhh（四个十六进制数字）对应的 UTF-16 代码单元。
\u{hhhh} 或 \u{hhhhh} |（仅当设置了 u 标志时。）匹配与 Unicode 值 U+hhhh 或 U+hhhhh（十六进制数字）对应的字符。
\p{UnicodeProperty}，\P{UnicodeProperty} | 根据字符的 Unicode 字符属性匹配字符（例如，仅匹配表情符号字符、日文片假名字符、中文汉字字符或日文汉字字符等）。
\ | 指示应特殊处理或“转义”后面的字符。它表现为两种方式之一。<br>对于通常按字面处理的字符，表示下一个字符是特殊的，不能按字面解释。例如，/b/ 匹配字符“b”。通过在“b”前面放置反斜杠，即使用 /\b/，字符变得特殊以表示匹配单词边界。<br>对于通常被特殊对待的字符，表示下一个字符不是特殊的，应该按字面意思解释。例如，“*”是一个特殊字符，表示应该匹配前面的字符出现 0 次或多次；例如，/a\*/ 示匹配 0 个或多个“a”。要从字面上匹配 * 需在其前面加上反斜杠；例如，/a\\\*/ 匹配“a\*”。<br>备注：要从字面上匹配此字符，请将其转义。换句话说就是搜索 \ 需要使用 /\\\\/。
x\|y | 析取：匹配“x”或“y”。每个由管道符 (\|) 分隔的部分称为一个可选项。例如，/green\|red/ 匹配“green apple”中的“green”和“red apple”中的“red”。<br>备注： 析取是指定“一组选择”的另一种方式，但它不是字符类。析取不是原子的——你需要使用组使其成为一个更大的模式的一部分。[abc] 在功能上等同于 (?:a\|b\|c)。

### 组和范围（Groups and Ranges）

表示表达式字符的分组和范围

字符 | 含义
---|---
(x) | 捕获组：匹配 x 并记住匹配项。例如，/(foo)/匹配并记住“foo bar”中的“foo” <br>正则表达式可以有多个捕获组。结果，匹配通常在数组中捕获的组，该数组的成员与捕获组中左括号的顺序相同。这通常只是捕获组本身的顺序。当捕获组被嵌套时，这一点非常重要。使用结果元素的索引 ([1], ..., [n]) 或从预定义的 RegExp 对象的属性 ($1, ..., $9).<br>捕获组会带来性能损失。如果不需要收回匹配的子字符串，请选择非捕获括号 (见下面)。<br>String.match() 不会返回组，如果设置了 /.../g 标志。但是，您仍然可以使用 String.matchAll() to get all matches.<br>match() 不会返回组，如果/…但是，您仍然可以使用 String.matchAll() 来获取所有匹配项。
(?\<Name\>x) | 具名捕获组：匹配"x"并将其存储在返回的匹配项的 groups 属性中，该属性位于\<Name\>指定的名称下。尖括号 (< 和 >) 用于组名。<br>例如，使用正则 /-(?\<customName>\w)/ 匹配“web-doc” 中的“d” <br>'web-doc'.match(/-(?\<customName\>\w)/).groups //{customName: "d"}
(?:x) | 非捕获组：匹配 “x”，但不记得匹配。不能从结果数组的元素中收回匹配的子字符串 ([1], ..., [n]) or from the predefined RegExp object's properties ($1, ..., $9).

### 量词（Quantifiers）

表示要匹配的字符或表达式的数量。

字符 | 含义
---|---
x* | 将前面的项“x”匹配 0 次或更多次。例如，/bo*/匹配“A ghost booooed”中的“boooo”和“A bird warbled”中的“b”，但在“A goat grunt”中没有匹配。
x+ | 将前一项“x”匹配 1 次或更多次。等价于{1,}。例如，/a+/匹配“candy”中的“a”和“caaaaaaandy”中的“a”。
x? | 将前面的项“x”匹配 0 或 1 次。例如，/e?le?/匹配 angel 中的 el 和 angle 中的 le。<br>如果立即在任何量词*、+、?或{}之后使用，则使量词是非贪婪的 (匹配最小次数)，而不是默认的贪婪的 (匹配最大次数)。
x{n} | 其中“n”是一个正整数，与前一项“x”的 n 次匹配。例如，/a{2}/ 不匹配“candy”中的“a”，但它匹配“caandy”中的所有“a”，以及“caaandy”中的前两个“a”。
x{n,} | 其中，“n”是一个正整数，与前一项“x”至少匹配“n”次。例如，/a{2，}/不匹配“candy”中的“a”，但匹配“caandy”和“caaaaaaandy”中的所有 a。
x{n,m} | 其中，“n”是 0 或一个正整数，“m”是一个正整数，而 m > n 至少与前一项“x”匹配，最多与“m”匹配。例如，/a{1,3}/不匹配“cndy”中的“a”，“candy”中的“a”，“caandy”中的两个“a”，以及“caaaaaaandy”中的前三个“a”。注意，当匹配“caaaaaaandy”时，匹配的是“aaa”，即使原始字符串中有更多的“a”。
x*? |  默认情况下，像 * 和 + 这样的量词是“贪婪的”，这意味着它们试图匹配尽可能多的字符串。?量词后面的字符使量词“非贪婪”：意思是它一旦找到匹配就会停止。

## 通过标志进行高级搜索

标志 | 描述
---|---
g|全局搜索。
i|不区分大小写搜索。
m|多行搜索。
s|允许 . 匹配换行符。
u|使用 unicode 码的模式进行匹配。
y|执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。

## 使用正则表达式

方法 | 描述
---|---
exec|一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。
test|一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。
match|一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。
matchAll|一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。
search|一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回 -1。
replace|一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。
split|一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。